# 第二次作业
&emsp;第一次课由于迟迟找不到bug的原因，于是配置了qt下的opencv环境，在qt中实现了图像显示，图像腐蚀，图像模糊与图像的边缘检测，由于系统后来进行了重装，仅保留了一张截图。![](007.JPG)

&emsp;后来将系统重装后并重新调试了环境，在VS中运行代码得到了以下结果：
>1. 图像腐蚀![](008.png)
>2. 图像模糊![](009.png)
>3. 边缘检测![](010.png)

代码总结：
1. 图像腐蚀：getStructuringElement()函数实现腐蚀效果，主要通过图像中的暗色部分腐蚀图像中的高亮部分，达到图像腐蚀的效果,这个函数的第一个参数表示内核的形状，有三种形状可以选择。
>1. 矩形：MORPH_RECT;
>2. 交叉形：MORPH_CROSS;
>3. 椭圆形：MORPH_ELLIPSE;

第二和第三个参数分别是内核的尺寸以及锚点的位置。一般在调用erode以及dilate函数之前，先定义一个Mat类型的变量来获得getStructuringElement函数的返回值。对于锚点的位置，有默认值Point（-1,-1），表示锚点位于中心点。element形状唯一依赖锚点位置，其他情况下，锚点只是影响了形态学运算结果的偏移。

2. 图像模糊：  
  通过调用blur( srcImage, dstImage, Size(7, 7))函数，通过均值滤波对图像进行降噪处理,均值滤波是指使用模板核算子覆盖区域内所有像素的加权平均，它用一个点邻域内像素的平均灰度值来代替这个点的灰度，常见的核算子有3x3，此时模板区域内的元素有9个，均值滤波就是也就是指当前中心像素点的值用1/9(a1+a2+...+a9)来代替。

均值滤波处理比较简单，因此计算速度比较快，但是均值滤波本身存在着固有的缺陷（振铃效应明显），因此不能很好地保护图像的细节，在图像去噪的同时也破坏了图像的细节部分，从而使得图像变得模糊，导致不能很好地去除噪声点。

OpenCV中使用blur()函数来实现均值滤波，也称为归一化滤波器，函数的声明如下：
>void blur( InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT );
3. 边缘检测：  
 通过cvtColor(srcImage, grayImage, COLOR_BGR2GRAY)函数先将图像灰度化，再调用blur( grayImage, edge, Size(3,3) )降噪，最后通过Canny算子实现边缘检测。
 >InputArray src: 输入图像即要进行颜色空间变换的原图像，可以是Mat类

 >OutputArray dst: 输出图像即进行颜色空间变换后存储图像，也可以Mat类

>int code: 转换的代码或标识，即在此确定将什么制式的图片转换成什么制式的图片

>int dstCn = 0: 目标图像通道数，如果取值为0，则由src和code决定

函数的作用是将一个图像从一个颜色空间转换到另一个颜色空间，但是从RGB向其他类型转换时，必须明确指出图像的颜色通道，前面我们也提到过，在opencv中，其默认的颜色制式排列是BGR而非RGB。所以对于24位颜色图像来说，前8-bit是蓝色，中间8-bit是绿色，最后8-bit是红色。常见的R,G,B通道的取值范围为：
>0-255 :CV_8U类型图片

>0-65535: CV_16U类型图片

>0-1: CV_32F类型图片

对于线性变换来说，这些取值范围是无关紧要的。但是对于非线性转换，输入的RGB图像必须归一化到其对应的取值范围来或得最终正确的转换结果，例如从RGB->L*u*v转换。


心得体会：通过本次课程，我初步了解了opencv,配置完成opencv后，成功完成了四个简单的图像处理程序，了解了一些函数的具体应用方法，知道了函数背后的意义，对接下来的学习有很大的作用。
